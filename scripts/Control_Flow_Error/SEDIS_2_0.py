import utils
import fileinput
from os import path
import random

###################################################################################################################
#
# This is a new type of CFE detection technique. Each block must have two signatures.
# 1) Compile time signature (C_sig) is generated by XOR'ing the instruction opcodes within that basic block except the
#    branch instruction at end.
# 2) Random signature (R_sig) assigned at compile time, which will also act as the expected signature.
#
# Both signatures will be 8-bits long. (since xori can take in 12 bits in the 'imm' field)
#           Note: This is much more efficient than having LI (load immediate) followed by a XOR Operation
#
#
# The initial block will have both C_sig set to 0 at the start of the block. Csig is stored in s11
# As we being executing the instructions in block-0, we will calculate the C_sig by XOR'ing instruction opcodes, and
# storing the result in s11.
# If the final instruction is not a conditional branch (i.e. is either an unconditional branch or not-a-branch
# instruction, then C_sig is XOR'ed with temporary signature (T_sig) defined as C_sig XOR R_sig_successor.
# This changes the value of C_sig stored in s11 to be equal to the R_sig of the successor block.
#
# Once the program execution reaches the correct signature block, we will load the expected signature in this case the
# R_sig into s10, and then XOR with s11 (Updated to use XORI instruction as it replaces LI+XOR).
# If the control flow was correct, both s10 and s11 will hold the same R_sig
# value, thus resulting in a zero. Any value besides a zero must trigger an exception as there has been a control flow
# error.
#
# Once the signatures are verified at the start of the basic block, the s10 will not hold zero, and we can again begin
# calculating the opcode signatures of the next block.
#
###################################################################################################################


class SEDIS_2_0:
    def __init__(self, i_map, i_generate_signature_only=False):
        self.simlog = i_map.simlog

        # Length of signature in bytes
        # 2-bytes  =  8  bits
        # 3-bytes  = 12  bits
        # 4-bytes  = 16  bits
        # 8-bytes  = 32  bits
        # 16-bytes = 64  bits
        # 32-bytes = 128 bits
        #self.length_signature = 16

        self.original_map = i_map

        # Compile time signature (C_sig)
        self.compile_time_sig = []
        # Random signature (R_sig)
        self.random_sig = []
        # Temporary Signature (T_sig)
        self.temp_sig = []

        # This instruction map will have a 1-to-1 mapping between instructions
        # in .s and .objdump files.
        # Elements in array 0 belongs to .s file
        # Elements in array 1 belongs to .objdump
        self.instruction_map = [[]]
        self.new_asm_file = self.original_map.file_asm

        if i_generate_signature_only:
            self.remove_signature_checking_extended()

        self.process_blocks()

        # If i_generate_signature_only is True, then don't proceed any further
        if i_generate_signature_only:
            return

        utils.generate_instruction_mapping(self)

        # Generate the new assembly file
        self.generate_SEDIS_2_0_file_updated()

    # This function clears the objdump file to remove all "00000000000xxxxx <.Tx>:" and the blank line before it
    def clear_objdump_file(self, i_objdump_file):
        i_new_objdump_file = []
        for i in range(len(i_objdump_file)):
            i_line = i_objdump_file[i]
            print(str(i))
            if (i_line.startswith("000000") ) and (('<.T') in i_line):
                if i_new_objdump_file[-1] is ' ':
                    del i_new_objdump_file[-1]
                else:
                    self.simlog.error("The last element in the objdump file must be a blank line")
                    raise Exception
            else:
                i_new_objdump_file.append(i_line)
        return i_new_objdump_file

    def generate_SEDIS_2_0_file_updated(self):
        i_block = 0
        i_line_num_new_asm_file = 0

        # 1. Loop the asm file lines until the end of file
        while (i_line_num_new_asm_file < len(self.new_asm_file)):

            # Return once all the blocks are processed
            if i_block == len(self.original_map.blocks):
                return

            block_found = False
            i_line_asm = self.original_map.file_asm[i_line_num_new_asm_file]

            # There are two cases where a basic block can start from
            # 1. When a function beings within the asm file (make sure the first instruction within the function and
            # the block matches one another)
            if not i_line_asm.startswith('\t'):
                # Make sure the first instruction in asm function matches the first instruction in the block
                # Get the first instruction in this particular block for comparison
                i_line_block_obj = self.original_map.blocks[i_block].entries[0]
                # i_line_block_asm could get multiple hits
                i_line_block_asm = self.get_matching_asm_line_using_objdump_line(i_line_block_obj)
                for i in range(len(i_line_block_asm)):
                    if self.original_map.file_asm[i_line_num_new_asm_file + 1].split('\t', 1)[1] in i_line_block_asm[i]:
                        block_found = True
                        del i_line_block_obj, i_line_block_asm
                        break

            # 2. When a branch instruction is present within the function itself
            #    and the next instruction is the starting instruction of the next block
            else:  # Line starts with '\t'
                i_line_asm = i_line_asm.split('\t', 1)[1]
                if not i_line_asm.startswith('.'):
                    if utils.is_branch_instruction(i_line_asm) or \
                            i_line_asm.startswith('li\ts10,') or \
                            i_line_asm.startswith('xori\ts11,s11,'):
                        # Get the first instruction in the next block for comparison
                        try:
                            i_line_block_obj = self.original_map.blocks[i_block].entries[0]
                        except:
                            self.simlog.info('done')
                        i_line_block_asm = self.get_matching_asm_line_using_objdump_line(i_line_block_obj)
                        try:
                            i_line_asm = self.original_map.file_asm[i_line_num_new_asm_file + 1].split('\t', 1)[1]
                            for i in range(len(i_line_block_asm)):
                                if self.original_map.file_asm[i_line_num_new_asm_file + 1].split('\t', 1)[1] in \
                                        i_line_block_asm[i]:
                                    block_found = True
                                    break
                            # It is possible that the 2nd instruction was also added as part of SEDIS, thus
                            # check the 3rd instruction
                            if not block_found:
                                i_line_asm = self.original_map.file_asm[i_line_num_new_asm_file + 2].split('\t', 1)[1]
                                for i in range(len(i_line_block_asm)):
                                    if self.original_map.file_asm[i_line_num_new_asm_file + 2].split('\t', 1)[1] in \
                                            i_line_block_asm[i]:
                                        block_found = True
                                        i_line_num_new_asm_file += 1
                                        break

                        except Exception as e:
                            # unexpected line encountered
                            i_line_num_new_asm_file += 1
                            continue

            if block_found:
                i_line_num_new_asm_file += 1

                # If it is the first block or initial block then just set s11 to 0.
                # It has no incoming edges
                if len(self.original_map.blocks[i_block].previous_block_id) == 0:
                    self.new_asm_file.insert(i_line_num_new_asm_file, '\tli\ts11,0')
                    i_line_num_new_asm_file += 1

                # All other blocks have at least one incoming edge
                else:
                    # If this isn't the first basic block, then it must have a predecessor block
                    # and that block must have set the Csig as Csig XOR Tsig ==> Rsig.

                    # Load expected random signature value into register s10
                    i_random_signature = self.random_sig[self.original_map.blocks[i_block].id]
                    self.new_asm_file.insert(i_line_num_new_asm_file, '\txori\ts11,s11,' +
                                             str(int(i_random_signature,16)) + "#" + i_random_signature +
                                             " #This is the Rsig for block-" + str(i_block))
                    i_line_num_new_asm_file += 1
                    # Check the expected value
                    self.new_asm_file.insert(i_line_num_new_asm_file, '\tbnez\ts11,' + utils.exception_handler_address)
                    i_line_num_new_asm_file += 1

                inst = 0
                while inst < len(self.original_map.blocks[i_block].entries):

                    # Get the next set of instructions to load from memory
                    l_remaining_opcode_length = self.get_opcode_length_to_jump_signature_length(inst, i_block, 16)

                    # When all possible instructions have been accounted for then break this while loop
                    if l_remaining_opcode_length == 0:
                        break

                    if l_remaining_opcode_length == 4:
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tlhu\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    elif l_remaining_opcode_length == 8:
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tlwu\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    elif l_remaining_opcode_length == 12:
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tld\ts10,18(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tslli\ts10,s10,16')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tsrli\ts10,s10,16')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    elif l_remaining_opcode_length == 16:
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tld\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1


                    elif l_remaining_opcode_length == 24:
                        self.simlog.error("Haven't been tested yet")
                        raise Error
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tlq\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    elif l_remaining_opcode_length == 28:
                        self.simlog.error("Haven't been tested yet")
                        raise Error
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tlq\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    elif l_remaining_opcode_length == 32:
                        self.simlog.error("Haven't been tested yet")
                        raise Error
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tauipc\ts10,0')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tlq\ts10,12(s10)')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txor\ts11,s11,s10')
                        i_line_num_new_asm_file += 1

                    else:
                        self.simlog.error("This case isn't possible or we haven't accounted for it.")
                        raise Exception

                    # Get the number of instructions to jump in the asm file
                    inst_to_jump = self.get_number_of_instructions_to_jump_asm_signature_length(inst, i_block,
                                                                                                l_remaining_opcode_length)
                    i_line_num_new_asm_file += inst_to_jump

                    # Get the number of instructions to jump in the basic blocks
                    inst_to_jump = self.get_number_of_instructions_to_jump_signature_length(inst, i_block,
                                                                                            l_remaining_opcode_length)
                    inst += inst_to_jump

                # We are already ahead of the last instruction in the block. Now get back before the last instruction
                # i_line_num_new_asm_file -= 1

                # We don't need to do anything if we are on the last block of the program
                if len(self.original_map.blocks[i_block].next_block_id) != 0:

                    # If the final instruction in this block is a load/store, arithmetic, or unconditional branch
                    # then we need to simply load Tsig into s10

                    last_line = self.new_asm_file[i_line_num_new_asm_file].strip()
                    if utils.is_unconditional_branch_instruction(last_line) or \
                            utils.is_arithmetic_instruction(last_line) or \
                            utils.is_load_store_instruction(last_line) or \
                            last_line.startswith("."): # If it is not a branch instruction then we have already
                                                       # reached the function declaration of the next block.
                        self.new_asm_file.insert(i_line_num_new_asm_file,
                                                '\tandi\ts11,s11,255 #0xFF is a mask')
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txori\ts11,s11,' +
                                                 str(int(self.temp_sig[i_block],16)) + "#" + self.temp_sig[i_block] +
                                                 " #This is the Tsig for block-" + str(i_block))

                    # The final instruction is a conditional branch instruction, which needs to be processed
                    # differently.
                    elif utils.is_conditional_branch_instruction(last_line):
                        new_line = last_line.replace(last_line.split('\t')[0], utils.get_opposite_branch_instruction(last_line))
                        new_line = new_line.rsplit(',', 1)[0]
                        new_line += ',.T' + str(i_block)
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\t' + new_line)
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txori\ts11,s11,' +
                                                 str(int(self.temp_sig[i_block][1],16)) + "#" + self.temp_sig[i_block][1] +
                                                 " #This is the Tsig for block-" + str(i_block) + "_0")
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tandi\ts11,s11,255 #0xFF is a mask')
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tj\t' + str(last_line.split(',')[-1]))
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '.T' + str(i_block) + ":")
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\txori\ts11,s11,' +
                                                 str(int(self.temp_sig[i_block][0],16)) + "#" + self.temp_sig[i_block][0] +
                                                 " #This is the Tsig for block-" + str(i_block) + "_1")
                        i_line_num_new_asm_file += 1
                        self.new_asm_file.insert(i_line_num_new_asm_file, '\tandi\ts11,s11,255 #0xFF is a mask')
                        i_line_num_new_asm_file += 1
                        del self.new_asm_file[i_line_num_new_asm_file]
                        i_line_num_new_asm_file -= 3

                    else:
                        self.simlog.error("Unrecognized instruction: " + str(last_line))
                        raise Exception

                i_block += 1

            i_line_num_new_asm_file += 1

        if i_block != len(self.original_map.blocks):
            self.simlog.error('Failed to process all blocks. Currently at block id # ' + str(i_block))
            raise Exception

    def process_blocks(self):
        # 1. Generate compile time signature for each block
        for i in range(len(self.original_map.blocks)):
            cum_sig = '0x0'
            compound_sig = ''
            j = 0
            while j < len(self.original_map.blocks[i].entries):

                # Don't consider branch instructions in the computation of compile time signature
                if utils.is_branch_instruction(self.original_map.blocks[i].entries[j]):
                    break

                sig = self.original_map.blocks[i].opcode[j]
                if len(compound_sig) + len(sig) <= 16:
                    compound_sig = sig + compound_sig
                    j = j + 1
                else:
                    cum_sig = hex(int(cum_sig, 16) ^ int(compound_sig, 16))
                    compound_sig = ''

            # Process remaining instruction signatures
            if compound_sig != '':
                cum_sig = hex(int(cum_sig, 16) ^ int(compound_sig, 16))
                compound_sig = ''
            # Finally add the cum_sig back to the list of compile time signatures (only store the last 8 bits)
            if len(cum_sig) > 4:
                cum_sig = '0x' + cum_sig[-2:]

            self.compile_time_sig.append(cum_sig)
        del i, j, cum_sig, sig, compound_sig

        # 2. Assign random signature (R_sig)
        random.seed(159357)
        for i in range(len(self.original_map.blocks)):
            returnVal = "0x" + hex(random.sample(range(1, len(self.original_map.blocks) * 65421), 1)[0])[-2:]
            self.random_sig.append(returnVal)

        # Calculate the temporary signature (T_sig).
        # Tsig is the temporary signature generated by XOR'ing the Csig of the current block with the Rsig
        # of the first successor block
        for i in range(len(self.original_map.blocks)):
            if len(self.original_map.blocks[i].next_block_id) == 0:
                t_sig = "0x0"
            elif len(self.original_map.blocks[i].next_block_id) == 1:
                t_sig = hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[0]], 16) ^
                            int(self.compile_time_sig[i], 16))
            elif len(self.original_map.blocks[i].next_block_id) == 2:
                i_current_block = i

                #if i_current_block+self.original_map.blocks[i].next_block_id[0] == i_current_block+1:
                #    t_sig = [hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[0]], 16) ^
                #               int(self.compile_time_sig[i], 16)),
                #             hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[1]], 16) ^
                #                 int(self.compile_time_sig[i], 16))]
                #else:
                t_sig = [hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[1]], 16) ^
                             int(self.compile_time_sig[i], 16)),
                         hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[0]], 16) ^
                             int(self.compile_time_sig[i], 16))]

            else:
                self.simlog.error("Not supported yet")
                raise Exception
                # if the final instruction is a return instruction, then we can potentially have many outgoing branches
                #t_sig = []
                #for j in range(len(self.original_map.blocks[i].next_block_id)):
                #    t_sig.append(hex(int(self.random_sig[self.original_map.blocks[i].next_block_id[j]], 16) ^
                #                int(self.compile_time_sig[i], 16)))

            self.temp_sig.append(t_sig)

    def get_matching_asm_line_using_objdump_line(self, i_line):
        # Definition: Checks for a matching line in the objdump file and returns the
        #             corresponding asm line
        line_instruction_map = 0
        list_matching_objects = []
        while line_instruction_map < len(self.instruction_map[0]):
            if i_line == self.instruction_map[1][line_instruction_map]:
                i_asm_instruction = self.instruction_map[0][line_instruction_map]
                list_matching_objects.append(i_asm_instruction)
            line_instruction_map += 1
        return list_matching_objects

    def get_opcode_length_to_jump_signature_length(self, i_inst, i_block, i_sig_length):
        num_inst = 0
        length_inst = 0
        while i_inst < len(self.original_map.blocks[i_block].opcode):
            # Don't consider the final branch instruction within the basic block
            if utils.is_branch_instruction(self.original_map.blocks[i_block].entries[i_inst]):
                return length_inst

            length = len(self.original_map.blocks[i_block].opcode[i_inst])
            if (length + length_inst) > i_sig_length:
                return length_inst
            else:
                length_inst += length
                num_inst += 1
            i_inst += 1
        return length_inst

    # Definition: gets the number of instructions to jump based on self.length_signature
    def get_number_of_instructions_to_jump_signature_length(self, i_inst, i_block, i_sig_length):
        num_inst = 0
        i_num_inst_combined = 0
        length_inst = 0
        while i_inst < len(self.original_map.blocks[i_block].opcode):

            length = len(self.original_map.blocks[i_block].opcode[i_inst])
            if (length + length_inst) > i_sig_length:
                return num_inst
            else:
                length_inst += length
                num_inst += 1
            i_inst += 1
        return num_inst

    def get_number_of_instructions_to_jump_asm_signature_length(self, i_inst, i_block, i_sig_length):
        num_inst = 0
        i_num_inst_combined = 0
        length_inst = 0
        while i_inst < len(self.original_map.blocks[i_block].opcode):

            # # # Get the first instruction in this particular block for comparison
            i_line_block_obj = self.original_map.blocks[i_block].entries[i_inst]
            # # # i_line_block_asm could get multiple hits
            i_line_block_asm = self.get_matching_asm_line_using_objdump_line(i_line_block_obj)
            i_num_inst_combined = len(i_line_block_asm[0].split(";"))

            length = len(self.original_map.blocks[i_block].opcode[i_inst])
            if (length + length_inst) > i_sig_length:
                return num_inst
            else:
                length_inst += length
                num_inst += i_num_inst_combined
            i_inst += 1
        return num_inst

    # Just remove all instructions that accesses the signature checking registers
    # like s10/s11/t6 etc from the processed blocks
    def remove_signature_checking_extended(self):
        i = 0
        j = 0
        while i < (len(self.original_map.blocks)):
            j = 0
            while j < (len(self.original_map.blocks[i].entries)):
                i_inst = self.original_map.blocks[i].entries[j]
                if utils.is_instruction_signature_checking_asm(i_inst):
                    del self.original_map.blocks[i].entries[j]
                    del self.original_map.blocks[i].memory[j]
                    del self.original_map.blocks[i].opcode[j]
                    j -= 1
                j += 1
            i += 1
        return

    def remove_signature_checking(self, i_s_file, i_objdump_file):
        # Cleanup the .s file
        i = 0
        while i < len(i_s_file):
            l_found = False
            i_line = i_s_file[i]
            if i_line.startswith('\t'):
                i_line = i_line.strip()
                if not i_line.startswith('.'):
                    #if utils.is_instruction_signature_checking_asm(i_line):
                    if i_line == 'bnez\ts11,100': # This is the signature check to see if the Csig and Rsig are equal. This can safely be remove
                        i_s_file.remove(i_s_file[i])
                        i -= 1
            # User added function calls all starts with .T (example .T1, .T2 etc)
            elif i_line.startswith('.T'):
                i_line = i_line.strip()
                i_s_file.remove(i_s_file[i])
                i -= 1
            i += 1

        # Cleanup the .objdump file
        i = 0
        i_excpt_addr = hex(int(utils.exception_handler_address, 10)).split('0x')[-1]
        while i < len(i_objdump_file):
            i_line = i_objdump_file[i]

            if i_line.startswith("   "):
                address, opcode, instruction = i_objdump_file[i].split('\t', 2)
                l_params = instruction.split('\t')[-1]
                #if utils.is_signature_checking_register(l_params):
                #    i_objdump_file.remove(i_objdump_file[i])
                #    i -= 1

                # We also need to remove the j to exception handler
                l_params = (l_params.split(' ')[0]).split(",")
                for j in range(len(l_params)):
                    if (i_excpt_addr == l_params[j]) and (utils.is_branch_instruction(instruction.split('\t')[0])):
                        i_objdump_file.remove(i_objdump_file[i])
                        i_objdump_file.remove(i_objdump_file[i-1])
                        i -= 2

            if utils.is_signature_checking_function(i_line):
                # Case-1: Function declaration (00000000000102f2 <.T3>:)
                if i_line.startswith('00000'):
                    del i_objdump_file[i]
                    del i_objdump_file[i - 1]
                    i -= 2
                # Case-2: Instruction (   102e4:       00e7c763                blt     a5,a4,102f2 <.T3>)
                elif i_line.startswith("   "):
                    i_objdump_file.remove(i_objdump_file[i])
                    i -= 1
                else:
                    self.simlog.error("unrecognized input: " + str(i_line))
                    raise Exception
            i += 1

        return i_s_file, i_objdump_file

    def remove_signature_checking_old(self, i_s_file, i_objdump_file):
        # .s file cleanup
        i = 0
        while i < len(i_s_file):
            l_found = False
            i_line = i_s_file[i]
            if i_line.startswith('\t'):
                i_line = i_line.strip()
                if not i_line.startswith('.'):
                    if utils.is_instruction_signature_checking_asm(i_line):
                        i_s_file.remove(i_s_file[i])
                        i -= 1
            # User added function calls all starts with .T (example .T1, .T2 etc)
            elif i_line.startswith('.T'):
                i_line = i_line.strip()
                i_s_file.remove(i_s_file[i])
                i -= 1
            i += 1

        # Just remove all lines from the objdump file that access signature checking registers like s11/s10/t6
        i = 0
        i_excpt_addr = hex(int(utils.exception_handler_address, 10)).split('0x')[-1]
        while i < len(i_objdump_file):
            i_line = i_objdump_file[i]

            if i_line.startswith("   "):
                address, opcode, instruction = i_objdump_file[i].split('\t', 2)
                l_params = instruction.split('\t')[-1]
                if utils.is_signature_checking_register(l_params):
                    i_objdump_file.remove(i_objdump_file[i])
                    i -= 1

                # We also need to remove the j to exception handler
                l_params = (l_params.split(' ')[0]).split(",")
                for j in range(len(l_params)):
                    if (i_excpt_addr == l_params[j]) and (utils.is_branch_instruction(instruction.split('\t')[0])):
                        i_objdump_file.remove(i_objdump_file[i])
                        i -= 1

            if utils.is_signature_checking_function(i_line):
                # Case-1: Function declaration (00000000000102f2 <.T3>:)
                if i_line.startswith('00000'):
                    del i_objdump_file[i]
                    del i_objdump_file[i-1]
                    i -= 2
                # Case-2: Instruction (   102e4:       00e7c763                blt     a5,a4,102f2 <.T3>)
                elif i_line.startswith("   "):
                    i_objdump_file.remove(i_objdump_file[i])
                    i -= 1
                else:
                    self.simlog.error("unrecognized input: " + str(i_line))
                    raise Exception

            i += 1
        return i_s_file, i_objdump_file


    def update_opcodes(self, i_map, i_new_map):
        # Check the total number of official functions in both new and old maps
        if len(i_map.functions.f_instructions) != len(i_new_map.functions.f_instructions):
            self.simlog.error("We don't have the same number of functions")
            raise Exception

        # Check the total number of instructions in each function for both new and old maps
        for i in range(len(i_map.functions.f_instructions)):
            if len(i_map.functions.f_instructions[i].opcode) != len(i_new_map.functions.f_instructions[i].opcode):
                self.simlog.error(
                    "We don't have the same number of instructions in both the function:" + i_map.functions.f_names[i])
                raise Exception

        # Now check the opcodes in both old and new maps and then copy any changes from new to old map
        for i in range(len(i_map.functions.f_instructions)):
            for j in range(len(i_map.functions.f_instructions[i].opcode)):
                if i_map.functions.f_instructions[i].opcode[j] != i_new_map.functions.f_instructions[i].opcode[j]:
                    if not utils.is_branch_instruction(i_map.functions.f_instructions[i].instruction[j]):
                        x1 = i_map.functions.f_instructions[i].instruction[j]
                        y1 = i_new_map.functions.f_instructions[i].instruction[j]
                        old_opcode = i_map.functions.f_instructions[i].opcode[j]
                        new_opcode = i_new_map.functions.f_instructions[i].opcode[j]
                        i_map.functions.f_instructions[i].opcode[j] = i_new_map.functions.f_instructions[i].opcode[j]

                        # Also need to find a matching instruction in the blocks and update the opcode there
                        i_matching_instruction = 0
                        for k in range(len(i_map.blocks)):
                            for m in range(len(i_map.blocks[k].opcode)):
                                if old_opcode == i_map.blocks[k].opcode[m]:
                                    #print("We have a matching opcode that we have to update")
                                    i_map.blocks[k].opcode[m] = new_opcode
                                    i_matching_instruction += 1
                        #if i_matching_instruction > 1:
                            #print("Some how we updated the same opcode in two places. Please check manually")
                            #raise Exception
        return i_map

# This function searches the .s file and looks for different Tsig values within old and new objections.
# If there is a difference in Tsig then the file is updated accordingly
def update_signature(i_obj_old, i_obj_new, i_file):

        file = open(i_file, 'r')
        i_asm_file = file.read()
        file.close()

        if len(i_obj_old.temp_sig) != len(i_obj_new.temp_sig):
            self.simlog.error("The length of Tsig must match in the old and new object")
            raise Exception

        for i in range(len(i_obj_old.temp_sig)):
            if isinstance(i_obj_old.temp_sig[i], str):
                i_old_Tsig = i_obj_old.temp_sig[i]
                i_new_Tsig = i_obj_new.temp_sig[i]
            else:
                i_old_Tsig = i_obj_old.temp_sig[i][0]
                i_new_Tsig = i_obj_new.temp_sig[i][0]
                if i_old_Tsig != i_new_Tsig:
                    raise Exception #TODO: I want to see how this is handles. Remove exception later if all works well

            # No need to do anything if the signatures are already same
            if i_old_Tsig == i_new_Tsig:
                pass
            # Update the .s file defined within i_file
            else:
                i_old_Tsig_in_decimal = int(i_old_Tsig.split('0x')[-1], 16)
                i_obj_to_replace = "\txori\ts11,s11," + str(i_old_Tsig_in_decimal) + "#" + str(i_old_Tsig) + \
                                   " #This is the Tsig for block-" + str(i)

                i_new_Tsig_in_decimal = int(i_new_Tsig.split('0x')[-1], 16)
                i_new_obj_to_add_to_file = "\txori\ts11,s11," + str(i_new_Tsig_in_decimal) + "#" + str(i_new_Tsig) + \
                                   " #This is the updated Tsig for block-" + str(i)

                i_asm_file = i_asm_file.replace(i_obj_to_replace, i_new_obj_to_add_to_file)

        file = open(i_file, 'w')
        file.write(i_asm_file)
        file.close()


def update_blocks(i_old_map, i_new_map):
    if len(i_old_map.blocks) != len(i_new_map.blocks):
        self.simlog.error("Both maps should have the same amount of blocks")
        raise Exception

    for i in range(len(i_old_map.blocks)):
        i_new_map.blocks[i].next_block_id = i_old_map.blocks[i].next_block_id
        i_new_map.blocks[i].next_block_address = i_old_map.blocks[i].next_block_address
        i_new_map.blocks[i].previous_block_id = i_old_map.blocks[i].previous_block_id
        i_new_map.blocks[i].previous_block_address = i_old_map.blocks[i].previous_block_address
    return i_new_map